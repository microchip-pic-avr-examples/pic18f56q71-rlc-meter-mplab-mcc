/* Microchip Technology Inc. and its subsidiaries.  You may use this software 
 * and any derivatives exclusively with Microchip products. 
 * 
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER 
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED 
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A 
 * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION 
 * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
 * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
 * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS 
 * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE 
 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS 
 * IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF 
 * ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE 
 * TERMS. 
 */

#ifndef RLC_H
#define	RLC_H

#ifdef	__cplusplus
extern "C" {
#endif
    
#include "mcp6s26.h"

#define EnableWaveformGenerator()       do { LATWbits.LATW2 = 1; } while(0)
#define DisableWaveformGenerator()      do { LATWbits.LATW2 = 0; } while(0)

#define EnableADCTrigger()              do { LATWbits.LATW1 = 1; } while(0)
#define DisableADCTrigger()             do { LATWbits.LATW1 = 0; } while(0)

#define EnableClock()                   do { LATWbits.LATW0 = 1; } while(0)
#define DisableClock()                  do { LATWbits.LATW0 = 0; } while(0)

#define SelectCurrent()                 do { MCP6S26_Write_Double_Command(MCP6S26_WRITE_INS | MCP6S26_CH, MCP6S26_MUX_CH3, MCP6S26_MUX_CH2); } while(0)
#define SelectVoltage()                 do { MCP6S26_Write_Double_Command(MCP6S26_WRITE_INS | MCP6S26_CH, MCP6S26_MUX_CH1, MCP6S26_MUX_CH2); } while(0)

#define GainSet(x)                      do { MCP6S26_Write_Double_Command(MCP6S26_WRITE_INS | MCP6S26_GAIN, x, x); } while(0)   
  
#define PI             3.141592654

#define FREQ            1000UL  
#define WAVE_STEPS      250

#define TIMER0_PERIOD    ((_XTAL_FREQ / (16 * WAVE_STEPS * FREQ)) - 1)

typedef enum {
    TIMESAMPLING_RATE_3 = 0,
    TIMESAMPLING_RATE_7,
    TIMESAMPLING_RATE_9,
    TIMESAMPLING_RATE_11,
    TIMESAMPLING_RATE_13,
    TIMESAMPLING_RATE_17,
    TIMESAMPLING_RATE_19,
    TIMESAMPLING_RATE_21,
    TIMESAMPLING_RATE_23
} sampling_rate_t;

typedef enum {
    VOLTAGE_PREPARE = 0,
    VOLTAGE_CALIBRATION,
    CURRENT_PREPARE,
    CURRENT_CALIBRATION,
    WRITE_CALIBRATION    
} calibration_state_t;

/*
 * TIMESAMPLING_RATE 
 * 
 *    Select the timesampling to ensure that ADC aquiring frequency is lower that 70 kHz
 *    The aquiring rate is computed as 
 *       FREQ * WAVE_STEPS / TIMESAMPLING_RATE
 * 
 *    TIMESAMPLING_RATE accepted values 3, 7, 9, 11, 13, 17, 19, 21, 23
 * 
 */    
#define TIMESAMPLING_RATE       TIMESAMPLING_RATE_17

#if WAVE_STEPS == 250

const uint8_t waveROM250[] __at(0x001000) = 
{
    32, 32, 33, 33, 34, 34, 34, 35, 35, 36, 36, 36, 37, 37, 38, 38, 38, 39, 39, 39,
    40, 40, 40, 41, 41, 41, 42, 42, 42, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45,
    46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48,
    48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 47, 47, 47, 47, 47, 47,
    46, 46, 46, 46, 46, 46, 45, 45, 45, 45, 44, 44, 44, 44, 43, 43, 43, 42, 42, 42,
    41, 41, 41, 40, 40, 40, 39, 39, 39, 38, 38, 38, 37, 37, 36, 36, 36, 35, 35, 34,
    34, 34, 33, 33, 32, 32, 32, 31, 31, 30, 30, 30, 29, 29, 28, 28, 28, 27, 27, 26,
    26, 26, 25, 25, 25, 24, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 20, 20, 20,
    20, 19, 19, 19, 19, 18, 18, 18, 18, 18, 18, 17, 17, 17, 17, 17, 17, 17, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17,
    17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21,
    21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 28,
    28, 28, 29, 29, 30, 30, 30, 31, 31, 32
};

#else
    #error "The supported number of steps is 250"
#endif

const float sinTable[63] =
{
    0.000000000000, 0.025130095443, 0.050244318180, 0.075326805528, 0.100361714851, 0.125333233564, 0.150225589121, 0.175023058975, 
    0.199709980514, 0.224270760949, 0.248689887165, 0.272951935517, 0.297041581577, 0.320943609807, 0.344642923175, 0.368124552685, 
    0.391373666837, 0.414375580993, 0.437115766651, 0.459579860621, 0.481753674102, 0.503623201636, 0.525174629961, 0.546394346734, 
    0.567268949127, 0.587785252292, 0.607930297695, 0.627691361291, 0.647055961569, 0.666011867434, 0.684547105929, 0.702649969799, 
    0.720309024888, 0.737513117358, 0.754251380736, 0.770513242776, 0.786288432137, 0.801566984871, 0.816339250717, 0.830595899196, 
    0.844327925502, 0.857526656194, 0.870183754670, 0.882291226435, 0.893841424151, 0.904827052466, 0.915241172621, 0.925077206834, 
    0.934328942457, 0.942990535893, 0.951056516295, 0.958521789017, 0.965381638833, 0.971631732915, 0.977268123568, 0.982287250729, 
    0.986685944208, 0.990461425697, 0.993611310520, 0.996133609143, 0.998026728428, 0.999289472641, 0.999921044204   
};

const float cosTable[63] =
{
    1.000000000000, 0.999684189283, 0.998736956606, 0.997158900261, 0.994951016981, 0.992114701314, 0.988651744738, 0.984564334529, 
    0.979855052384, 0.974526872787, 0.968583161129, 0.962027671586, 0.954864544747, 0.947098304995, 0.938733857654, 0.929776485888, 
    0.920231847366, 0.910105970685, 0.899405251566, 0.888136448814, 0.876306680044, 0.863923417193, 0.850994481795, 0.837528040042, 
    0.823532597628, 0.809016994375, 0.793990398648, 0.778462301567, 0.762442511011, 0.745941145424, 0.728968627421, 0.711535677209, 
    0.693653305813, 0.675332808121, 0.656585755753, 0.637423989749, 0.617859613090, 0.597904983058, 0.577572703422, 0.556875616488, 
    0.535826794979, 0.514439533782, 0.492727341548, 0.470703932165, 0.448383216090, 0.425779291565, 0.402906435714, 0.379779095522, 
    0.356411878713, 0.332819544523, 0.309016994375, 0.285019262470, 0.260841506290, 0.236498997024, 0.212007109922, 0.187381314586, 
    0.162637165195, 0.137790290685, 0.112856384873, 0.087851196551, 0.062790519529, 0.037690182670, 0.012566039883 
};

const float opaGainTable[] = {1.0, 2.0, 4.0, 5.0, 8.0, 10.0, 16.0, 32.0};

const uint8_t timesamplingRates[] = {3, 7, 9, 11, 13, 17, 19, 21, 23};

void Process_Impedance_Values(void);

float Get_ZReal(void);
float Get_ZImag(void);
float Get_VReal(void);
float Get_VImag(void);
float Get_IReal(void);
float Get_IImag(void);
float Get_ZArg(void);
float Get_ZMod(void);
float Get_VRealUnscaled(void);
float Get_VImagUnscaled(void);
float Get_IRealUnscaled(void);
float Get_IImagUnscaled(void);
float Get_Gain(uint8_t index);
void Set_VGain(uint8_t index);
void Set_IGain(uint8_t index);


#ifdef	__cplusplus
}
#endif

#endif	/* RLC_H */

